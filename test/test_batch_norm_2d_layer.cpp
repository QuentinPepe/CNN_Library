#include <gtest/gtest.h>
#include "BatchNorm2d.h"
#include "Tensor4D.h"
#include "Vector.h"
#include <cmath>

namespace nnm {

    class BatchNorm2dTest : public ::testing::Test {
    protected:
        static constexpr float epsilon = 1e-4f;


    };


    TEST_F(BatchNorm2dTest, ForwardPass2) {
        nnm::Tensor4D input_tensor({
                                           {{{-1.125840f, -1.152360f, -0.250579f, -0.433879f, 0.848710f},  {0.692009f, -0.316013f, -2.115219f, 0.322275f,  -1.263335f}, {0.349983f,  0.308134f, 0.119842f,  1.237658f,  1.116777f},  {-0.247278f, -1.352654f, -1.695931f, 0.566651f,  0.793508f}}, {{0.598839f,  -1.555095f, -0.341360f, 1.853006f, 0.750189f}, {-0.585498f, -0.173397f, 0.183478f, 1.389366f,  1.586334f}, {0.946298f,  -0.843677f, -0.613583f, 0.031593f,  -0.492677f}, {0.248415f, 0.439696f, 0.112411f,  0.640792f, 0.441156f}}, {{-0.102310f, 0.792444f,  -0.289668f, 0.052507f, 0.522860f},  {2.302205f, -1.468894f, -1.586689f, -0.673090f, 0.872831f},  {1.055357f, 0.177844f,  -0.230335f, -0.391754f, 0.543295f}, {-0.395158f, -0.446217f, 0.744021f, 1.520980f,  3.410503f}}},
                                           {{{-1.531184f, -1.234135f, 1.819725f,  -0.551529f, -0.569248f}, {0.919971f, 1.110816f,  1.289874f,  -1.478174f, 2.567233f},  {-0.473120f, 0.335551f, -1.629326f, -0.549744f, -0.479834f}, {-0.499682f, -1.066980f, 1.114940f,  -0.140671f, 0.805754f}}, {{-0.093348f, 0.687050f,  -0.838315f, 0.000892f, 0.841894f}, {-0.400034f, 1.039462f,  0.358153f, -0.246001f, 2.302516f}, {-1.881689f, -0.049727f, -1.044979f, -0.956501f, 0.033532f},  {0.710087f, 1.645867f, -1.360169f, 0.344565f, 0.519868f}}, {{-2.613322f, -1.696474f, -0.228242f, 0.279955f, -0.701524f}, {1.036687f, -0.603670f, -1.278765f, 0.092950f,  -0.666100f}, {0.608047f, -0.730020f, 1.375038f,  0.659631f,  0.476557f}, {-1.016307f, 0.180367f,  0.108332f, -0.754823f, 0.244319f}}}
                                   });

// BatchNorm2d parameters
        nnm::Tensor4D gamma({
                                    1.000000f,
                                    0.500000f,
                                    2.000000f
                            });
        nnm::Tensor4D beta({
                                   0.000000f,
                                   1.000000f,
                                   -1.000000f
                           });
        nnm::Tensor4D running_mean({
                                           -0.009593f,
                                           0.015574f,
                                           0.002958f
                                   });
        nnm::Tensor4D running_var({
                                          1.017515f,
                                          0.985897f,
                                          1.022240f
                                  });

// Expected output tensor
        nnm::Tensor4D expected_output({
                                              {{{-0.962161f, -0.986936f, -0.144473f, -0.315716f, 0.882505f},  {0.736111f, -0.205603f, -1.886459f, 0.390698f,  -1.090611f}, {0.416584f,  0.377487f, 0.201581f,  1.245868f,  1.132939f},  {-0.141390f, -1.174055f, -1.494752f, 0.618999f,  0.830934f}}, {{1.242092f, 0.065279f, 0.728409f, 1.927312f, 1.324783f}, {0.595024f, 0.820177f, 1.015157f, 1.674000f, 1.781615f}, {1.431928f,  0.453966f, 0.579679f, 0.932174f, 0.645737f}, {1.050636f, 1.155143f, 0.976330f, 1.265013f, 1.155941f}}, {{-1.241626f, 0.397540f,  -1.584861f, -0.958005f, -0.096331f}, {3.163383f, -3.745173f, -3.960970f, -2.287281f, 0.544807f},  {0.879190f, -0.728392f, -1.476166f, -1.771881f, -0.058895f}, {-1.778116f, -1.871656f, 0.308829f,  1.732198f,  5.193756f}}},
                                              {{{-1.340842f, -1.063332f, 1.789647f,  -0.425627f, -0.442181f}, {0.949078f, 1.127370f,  1.294649f,  -1.291318f, 2.487984f},  {-0.352376f, 0.403101f, -1.432528f, -0.423960f, -0.358649f}, {-0.377191f, -0.907173f, 1.131222f,  -0.041796f, 0.842374f}}, {{0.863912f, 1.290287f, 0.456896f, 0.915401f, 1.374886f}, {0.696353f, 1.482828f, 1.110592f, 0.780509f, 2.172904f}, {-0.113157f, 0.887745f, 0.343984f, 0.392324f, 0.933234f}, {1.302873f, 1.814141f, 0.171778f, 1.103168f, 1.198946f}}, {{-5.841737f, -4.162095f, -1.472330f, -0.541327f, -2.339371f}, {0.844986f, -2.160105f, -3.396862f, -0.883915f, -2.274475f}, {0.059729f, -2.391575f, 1.464837f,  0.154230f,  -0.181157f}, {-2.916047f, -0.723770f, -0.855736f, -2.437014f, -0.606612f}}}
                                      });

        // Create BatchNorm2d layer
        nnm::BatchNorm2d bn(input_tensor.getChannels());
        bn.set_parameters(gamma, beta, running_mean, running_var);

        // Perform forward pass
        nnm::Tensor4D output = bn.forward(input_tensor);

        // Compare output with expected output
        ASSERT_EQ(output.getBatchSize(), expected_output.getBatchSize());
        ASSERT_EQ(output.getChannels(), expected_output.getChannels());
        ASSERT_EQ(output.getHeight(), expected_output.getHeight());
        ASSERT_EQ(output.getWidth(), expected_output.getWidth());

        const float epsilon = 1e-1f;
        for (size_t n = 0; n < output.getBatchSize(); ++n) {
            for (size_t c = 0; c < output.getChannels(); ++c) {
                for (size_t h = 0; h < output.getHeight(); ++h) {
                    for (size_t w = 0; w < output.getWidth(); ++w) {
                        EXPECT_NEAR(output(n, c, h, w), expected_output(n, c, h, w), epsilon)
                                            << "Mismatch at position (" << n << ", " << c << ", " << h << ", " << w
                                            << ")";
                    }
                }
            }
        }
    }

} // namespace nnm